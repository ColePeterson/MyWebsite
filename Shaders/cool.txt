precision mediump float;
	
	uniform vec2 resolution;
	uniform float time;


#define FAR 30.0
#define DISTANCE_BIAS 0.75
#define HASHSCALE1 .1031

mat2 rot(float a) {
    return mat2(cos(a), -sin(a), sin(a), cos(a));
}

float N21(vec2 p){
 	return fract(sin(p.x*100.0 + p.y*6574.) * 5647.0);
}

float ns(vec2 uv)
{
    vec2 id = floor(uv);
    vec2 lv = fract(uv);
    
    lv = lv*lv*(3.0-2.0*lv);
    
    float bl = N21(id);
    float br = N21(id + vec2(1,0));
    float b = mix(bl, br, lv.x);
    
    float tl = N21(id + vec2(0,1));
    float tr = N21(id + vec2(1,1));
    float t = mix(tl, tr, lv.x);
    
    return mix(b, t, lv.y);
    
}

float fbm(vec2 uv)
{
    float a = 0.1;
    float b = 0.7;
    
	float c = ns(uv * 4.0);
    
    a+=b;
    c += ns(uv * 8.) * 0.5;
    a+=b;
    c += ns(uv * 16.) * 0.25;
    a+=b;
    c += ns(uv * 32.) * 0.125;
    a+=b;
    c += ns(uv * 64.) * 0.0625;
    
    c /= 2.0;
    
    return c;
}

float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

float sdCil( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}
float opSmooth( float d1, float d2, float k ) {
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) - k*h*(1.0-h); }

float sdCapsule(vec3 p, vec3 a, vec3 b, float r)
{
	vec3 ab = b-a;
	vec3 ap = p-a;
	
	float t = dot(ab, ap) / dot(ab, ab);
	t = clamp(t, 0.0, 1.0);
	
	vec3 c = a + t*ab;
	
	return length(p-c) - r;
	
}

float sdTorus(vec3 p, vec2 r)
{
	float x = length(p.xz)-r.x;
	return length(vec2(x, p.y))-r.y;
	
}

float minDist = 999.;
float mat = -1.0;

void checkID(float tDist, float m, int f)
{
	if(tDist < minDist && f != 1)
	{
		minDist = tDist;
		mat = m;
	}
}	

#define lPos vec3(0.5, 14.0, -10.5)*50.
#define SP 1.
#define A 0.5
float map(vec3 p, int f)
{
	vec3 p0 = p - vec3(1.0, -1.0, 0.0); // plane
	vec3 p3 = p - vec3(0.0, 0.0, 4.0); // box
	
	float d = 999.0;
	
	// Plane
	d = min(d, p0.y);
	checkID(d, 1.0, f);
	
	// Box
	vec3 b = vec3(4.0, 0.0, 4.0);
	p3.z+=time*SP;
	p3.x+=sin(time*SP)*A;
	p3 = mod(p3, b)-0.5*b;
	p3.xz*=rot(0.7);
	p3.yz*=rot(0.7);
	
	
	//d = min(d, sdTorus(p3, vec2(0.70, 0.42))) ;
	d = min(d,length(p3)-1.0);
	checkID(d, 3.0, f);
	
	return d;
}

vec3 getNormal(vec3 p)
{
    vec2 e = vec2(0.0035, -0.0035); 
    return normalize(
        e.xyy * map(p + e.xyy,1) + 
        e.yyx * map(p + e.yyx,1) + 
        e.yxy * map(p + e.yxy,1) + 
        e.xxx * map(p + e.xxx,1));
}


vec3 traceRef(vec3 ro, vec3 rd){
    
    float t = 0.0, d = 0.0, ns = 0.0, md = 0.0;
    
    for (int i = 0; i < 48; i++)
    {
        d = map(ro + rd*t,0);
		md = min(md, d);
		
        if(abs(d)<0.0025)
		{	
			md = 0.0;		
            break;  
		}
        if(t>FAR) 
        {
            t = FAR;
            break;
        }
        t += d;
		ns++;
    }
    
    return vec3(t, ns, md);
}



vec3 trace(vec3 p, vec3 rd)
{
	float t=0.0, d=0.0, ns=0.0, md = 999.0; 
   
    for (int i = 0; i < 100; i++) 
    {
        d = map(p + rd*t,0);
        md = min(md, d);
		
        if(abs(d)<0.001)
		{	
			md = 0.0;		
            break;  
		}
        if(t>FAR) 
        {
            t = FAR;
            break;
        }
        ns++;
        t += d * 0.75;
    }
    
	return vec3(t, ns, md);
	
}


float shadow(vec3 p, vec3 lp)
{
	float t = 0.0; 
    float d; 
	float md = 999.0;
    
	vec3 pl = normalize(lp - p);
	vec3 p2 = p + pl * 0.15;
	
    for (int i = 0; i < 32; i++) 
    {
		d = map(p2 + pl * t, 1);
		md = min(md, d);
		
		if(abs(d) < 0.002)
		{
			md = 0.0;
			break;
		}
		if(t >= dot(lp, lp))
			break;
		
		t += d ;
	}
	
	return md;
}

vec3 fog(vec3 col, float t)
{
	return mix( col, vec3(0.0, 0.0, 0.0), 1.0 - exp( -0.0008*t*t*t ));
}
#define B vec3(8.0, 8.0, 8.0)
vec3 hash33(vec3 p3)
{
	p3 = fract(p3 * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+19.19);
    return fract((p3.xxy + p3.yxx)*p3.zyx);

}
vec3 color(vec3 ro, vec3 rd, vec3 norm, float t, float ns, int mode)
{
    vec3 lp = ro + lPos; 
	vec3 ld = normalize(lp - (ro + rd*t)) * 10.;
    
	vec3 p = ro+rd*t;
	
    float lDist = max(length(ld), 0.001); // Light to surface distance.
    float atten = 1.0 / (1.0 + lDist*0.2 + lDist*lDist*0.1); // light attenuation 
    ld /= lDist;
    
    float diff = max(dot(norm, ld), 0.0);
    float spec = pow(max( dot( reflect(-ld, norm), -rd ), 0.0 ), 8.0);
	
	float ao = max(smoothstep(1.0, 0.0, ns / 40.), 0.1);
	float shd = max(smoothstep(0.00, 0.1, shadow(ro, lPos)), 0.1);
	
	vec3 alb = vec3(0);
	vec3 col = vec3(0);
	
	vec3 spcol = vec3(1.0, 0.6, 0.2)*spec*0.15*atten;
	
	if(t >= FAR)
		mat = 4.0;
	
	
	if(mat == 0.0)
	{
		alb = vec3(1.0, 1.0, 1.0);
		col = alb*(diff + 0.06);
	}
	if(mat == 1.0)
	{
		p.z += time*SP*2.;
		p.x+=sin(time*SP)*2.*A;
		vec2 rc = fract(p.xz*0.8) - 0.5;
		alb = vec3(0.8, 0.7, 0.6) * max(smoothstep(0.5, 0.53,dot(abs(rc), vec2(1.0, 1.0))), 0.0);
		//alb = vec3(0.0, 0.0, 1.0);
		col = alb*(diff + 0.06);
	}
	if(mat == 3.0)
	{
		//alb = vec3(0.0, 0.6, 0.0) * fbm(p.xy*0.7);
		//col = alb*(diff + 0.06);
		p.z += time*SP*2.;
		p.x+=sin(time*SP)*2.*A;
		vec3 b = vec3(8.0, 0.0, 8.0);
	
		vec3 id = floor(p*0.25 - 0.49);
		//p += hash33(id)*0.5;	
		vec3 rc = mod(p,b)-0.5*b;
	
	
		alb = hash33(id);
		
		col = alb*(diff + 0.06);
	}
	
	col += spcol;
	col *= ao;
	col *= shd;
	
    if(mode == 1)
		col = fog(col, t);
   
    return col;
    
}


void main()
{
    vec2 uv = 2.0 * vec2(gl_FragCoord.xy - 0.5*resolution.xy)/resolution.y; 
   
    vec3 ro = vec3(0.0, 0.0, 0.0); 
    vec3 rd = normalize(vec3(uv,2.0));
    //rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.22));
	vec3 col;
	
	// Main color
    vec3 t = trace(ro, rd);
	ro += rd * t.x;
    vec3 norm = getNormal(ro);
    col = color(ro, rd, norm, t.x, t.y, 0);
	
	mat = -1.0;
	minDist = 999.0;
	
	// Reflection;
	rd = reflect(rd, norm);
	vec3 t2 = traceRef(ro +  rd*.01, rd);
	ro += rd*t2.x;
	norm = getNormal(ro);
	col += color(ro, rd, norm, t2.x, t2.y, 1) * 0.04;
	
	
	col = fog(col, t.x);
	
	
	//float rfog = 1.0 - exp( -0.00026*t.x*t.x*t.x);
	//col = mix( col, vec3(0), rfog);
    gl_FragColor = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);
 
}