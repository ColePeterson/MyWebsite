precision mediump float;
uniform vec2 resolution;
uniform float time;



vec2 R;
const float pi = 3.14159;


mat2 rot(float a) {
    return mat2(cos(a), -sin(a), sin(a), cos(a));
}

float sdBox( vec3 p, vec3 b ){
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}
float sdCapsule(vec3 p, vec3 a, vec3 b, float r){
	vec3 ab = b-a;
	vec3 ap = p-a;
	float t = dot(ab, ap) / dot(ab, ab);
	t = clamp(t, 0.0, 1.0);
	vec3 c = a + t*ab;
	return length(p-c) - r;
}

float opSub( float d1, float d2 ) { return max(-d1,d2); }

float minDist = 999.;
float mat = -1.0;

void cd(float tDist, float m, out float tmat)
{
	if(tDist <minDist)
	{
		minDist = tDist;
		mat = m;
		tmat = m;
	}
}

#define lPos vec3(5.0, 4.2, -6.0)*12.

vec2 hash( vec2 p ) 
{
	p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );
	return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float simplex( in vec2 p )
{
    const float K1 = 0.366025404; 
    const float K2 = 0.211324865;

	vec2  i = floor( p + (p.x+p.y)*K1 );
    vec2  a = p - i + (i.x+i.y)*K2;
    float m = step(a.y,a.x); 
    vec2  o = vec2(m,1.0-m);
    vec2  b = a - o + K2;
	vec2  c = a - 1.0 + 2.0*K2;
    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
    return dot( n, vec3(70.0) );
}


vec2 map(vec3 p)
{
    float d = 999.0;
    float hmat = -1.0;
    
 	vec3 p0 = p - vec3(0.0, 0.65, 6.0); // sphere
    vec3 p1 = p - vec3(0.0, -0.5, 4.5); // box
    
    p1 += simplex(p1.xy*2. + time*0.5)*0.09; 
    
    float obj = sdCapsule(p0, vec3(-1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 0.5);
    
    float box = sdBox(p1, vec3(1.7, 1.0, 0.05));
    float plane = 1.0 + p.y;
    
    d = min(d, plane);
    cd(d, 1.0, hmat);
    
    d = min(d, box);
    cd(d, 0.0, hmat);
    
    d = min(d, obj);
    cd(d, 2.0, hmat);
    
    return vec2(d, hmat);
}

vec3 getNormal(in vec3 p) {

	const vec2 e = vec2(0.002, 0);
	return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x, map(p + e.yxy).x - map(p - e.yxy).x,	map(p + e.yyx).x - map(p - e.yyx).x));
}



float shadow(vec3 p, vec3 lp){
	
	float t = 0.0; 
    vec2 d = vec2(0); 
	float md = 999.0;
    
	vec3 pl = normalize(lp - p);
	vec3 p2 = p + pl * 0.15;
	
    for (int i = 0; i < 32; i++) 
    {
		d = map(p2 + pl * t);
		md = min(md, d.x);
		
		if(abs(d.x) < 0.002)
		{
			md = 0.0;
			break;
		}
		if(t >= dot(lp, lp))
			break;
		
		t += d.x ;
		
	}
	
	return md;
}

vec4 trace(vec3 ro, vec3 rd)
{
 	vec2 d;
    float t, md, ns = 0.0;
    
    minDist = 999.0;
    mat = -1.0;
    
    for(int i = 0; i < 64; i++)
    {
     	d = map(ro+rd*t);   
     	
        md = min(md, d.x);
        
        if(abs(d.x) <= 0.002 || t >= 150.0){break;}
 		
        t += abs(d.x) * 0.75;
        ns++;
    }
    
    return vec4(t, md, d.y, ns);
}

vec3 fog(vec3 col, float t){return mix( col, vec3(0.8, 0.8, 0.8), 1.0 - exp( -0.0005*t*t*t ));}

vec3 color(vec3 ro, vec3 rd, vec3 n, float t, float md, float mat, float ns)
{
    vec3 p = ro+rd*t;
    vec3 lp = p + lPos; 
	vec3 ld = normalize(lp - p);
    
	float pDist = max(length(p - ro), 0.001);
    float lDist = max(length(ld), 0.001);
    float atten = 1.0 / (1.0 + lDist*0.2 + lDist*lDist*0.1);
    ld /= lDist;
    
    float diff = max(dot(n, ld), 0.03);
    float spec = pow(max( dot( reflect(-ld, n), -rd ), 0.0 ), 12.0);
    //float shd = max(smoothstep(0.0, 0.02, shadow(ro, lPos)), 0.2);
    float occ = max(smoothstep(1.5, 0.0, ns / 85.), 0.06);
    
    vec3 spcol = vec3(0.9, 0.3, 0.1)*spec*0.35*atten;
	vec3 alb = vec3(0);
	vec3 col = vec3(0);
    
    
    if(mat == 0.0)
	{
		alb = vec3(0.6, 0.9, 0.9);
		col = alb*(diff + 0.02);
	}
    if(mat == 1.0)
	{
		vec2 rc = fract(p.xz*0.5) - 0.5;
		alb = vec3(0.9, 0.1, 0.1) * max(smoothstep(0.5, 0.57, dot(abs(rc), vec2(0.99, 0.99))), 0.0);
		col = alb*(diff + 0.06)*2.;
	}
    if(mat == 2.0)
	{
        vec2 coord = vec2(p.x, p.y)*0.5;
       
        alb = vec3(0.0, 1.0, 0.0);
		col = alb*(diff + 0.02);
	}
    col += spcol;
   // col *= shd;
    col *= occ;
    
 	col = fog(col, t);  
    
    return col;
}



void main()
{
    R = resolution.xy;
    vec2 uv = vec2(gl_FragCoord.xy.xy - 0.5*R.xy)/R.y;
  
    
    vec3 ro = vec3(0.0, 0.0, 0.0);
    vec3 rd = normalize(vec3(uv, 2.0));
    
    vec3 col, acol, norm, p;
	vec4 t, t2, t3; 
    
    t = trace(ro, rd);
    
    if(t.z == 0.0) // Hit transparent object
    {
        ro += rd*t.x; // go to its surface
        norm = getNormal(ro);
        acol = color(ro, rd, norm, t.x, t.y, t.z, t.w); // gather color of surface
        
        rd = refract(rd, norm,1.028);
        
        ro += rd*0.04;
        t2 = trace(ro, rd); // trace through surface
        ro += rd*t2.x;
        norm = getNormal(ro);
        
        ro += rd*0.04;
        t3 = trace(ro, rd); // trace out from surface to scene
        ro += rd*t3.x;
        norm = getNormal(ro);
        
        
        
        //acol *= 0.9;
        col = mix(color(ro, rd, norm, t3.x + t.x + t2.x, t2.y, t3.z, t3.w), acol,0.55);
       
    }
    else
    {
    	p = ro + rd*t.x;
    	norm = getNormal(p);
    	col = color(p, rd, norm, t.x, t.y, t.z, t.w);
    
    }
    
    
    
    
    
    
    gl_FragColor = vec4(col, 1.0);
    
}