precision mediump float;
uniform vec2 resolution;
uniform float time;


#define HASHSCALE1 .1031



vec2 m()
{
	return vec2(sin(time*1.6)*0.25, -0.05);
}

float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}
vec3 scene(vec2 uv, vec3 sc)
{
    vec3 col = vec3(0.0, 0.1, 0.2);
    
    
    //float sun = smoothstep(0.21, 0.2, length(uv)); // Round light
    float sun = smoothstep(0.21, 0.2, length(floor(uv*2.7 + 0.5 )));
    float size = 16.0 ;
  
    uv.x -= time*0.06;
   
    vec2 fuv = vec2(floor(uv*size));
    
    float b = floor(mod(fuv.x - fuv.y, 2.0)); // checker pattern
    //float b = floor(mod(fuv.x, 2.0)); // bar pattern
    
    
    col += sc * sun;
    
    col = mix(vec3(0.2, 0.0, 0.0), col, b);
    
    return col;
    
}

vec3 mask(vec3 c, vec3 c2)
{
    vec3 col = vec3(0);
    
    if(length(c) < 1.0)
    {
        col = vec3(0); 
    }
    else
    {
     	col = c2;   
    }
 	   
    return col;
}


const int nSamples = 128;

void main()
{
  
	vec2 uv = vec2(gl_FragCoord.xy - 0.5*resolution.xy)/resolution.y;
    vec2 uv2 = vec2(gl_FragCoord.xy - 0.5*resolution.xy)/resolution.y;
   
    vec3 sunCol = vec3(0.9, 0.8, 0.0);
    
    vec3 col = scene(uv, sunCol);
   	vec3 maskCol = mask(col, sunCol);
   	

    vec2 center = m().xy*1.0;
  
    float blurStart = 1.0;
    float blurWidth = -1.0;
    
  
    uv -= center;
    float precompute = blurWidth * (1.0 / float(nSamples - 1));
    
    
    
    for(int i = 0;i < nSamples; i++)
    {
        float scale = blurStart + (float(i)* precompute);
      
        vec3 temp = scene(uv * scale + center, sunCol);
        
       
        col += mask(temp, sunCol) * 0.90 * clamp(hash12(gl_FragCoord.xy + sin(time)), 0.5,0.6 ) * 1.5;
       
        //col += mask(temp, sunCol) * 0.90;
    }
   
    col /= float(nSamples);
    
   	col += scene(uv2, sunCol);
    

    gl_FragColor = vec4(col,1.0);
}





