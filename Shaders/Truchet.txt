precision mediump float;
uniform vec2 resolution;
uniform float time;
uniform vec3 mouse;

vec2 R;
const float pi = 3.14159;


mat2 rot(float a) {
    return mat2(cos(a), -sin(a), sin(a), cos(a));
}

vec2 m(){
    vec2 m = mouse.xy / resolution.xy-.5; 
    m.x *= resolution.x/resolution.y;
	return m;
}
float n12(vec2 p){
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

float noise(vec2 uv){
    vec2 id = floor(uv);
    vec2 lv = fract(uv);
    
    lv = lv*lv*(3.0-2.0*lv);
    
    return mix(mix(n12(id), n12(id + vec2(1,0)), lv.x), 
               mix(n12(id + vec2(0,1)), n12(id + vec2(1,1)), lv.x), 
               lv.y);
}

const float scale = 4.2;

vec3 Truchet(vec2 uv)
{
    uv += noise(uv*16.0)*0.025;
    
    vec2 fuv = fract(uv * scale) - 0.5;
    vec2 id = floor(uv * scale);
    
    float sw = 1.0;
    
    if(n12(id) > 0.5){
		fuv *= rot(pi / 2.0); 
        sw *= -1.0;
    }
   
    float thk = 0.2;
    float fuzz = 0.12;
    
   
    
    
    float val = 0.0;
    
    vec2 P = vec2(0.5);
    
    for(int i = 0; i < 2; i++)
    {
        if(i > 0){
            P *= -1.0;
        }
        
        vec2 V = normalize(P - fuv);
        vec2 B = P - 0.5*V;
        
        val += smoothstep(thk, thk - fuzz, length(fuv - B));
    } 	   
    
    return vec3(id, val);
}

float zval = 0.0;

vec3 color(vec2 uv)
{
    uv.y -= time*0.1 + 10.;
    vec3 tr = Truchet(uv);
    zval = tr.z;
    
    
    vec3 col = mix(vec3(1., 0., 0.), vec3(0.0,1.0,0.0), tr.z);
    
    return col;
}

float height(vec2 p){
    return color(p).r;
}

vec3 BumpedNormal(vec2 uv, float strength){
    float h = 0.0012;
    
    
    float dx = height(uv) - height(uv + vec2(h, .0));
    float dy = height(uv) - height(uv + vec2(0., h));
    
    return normalize( vec3(0., 0., -1.) + vec3(dx, dy, 0.)*strength);
}

void main()
{
    R = resolution.xy;
    vec2 uv = vec2(gl_FragCoord.xy - 0.5*R.xy)/R.y;
    
    vec2 m = mouse.xy / resolution.xy-.5; 
   
    m.x *= resolution.x/resolution.y;
   
    vec3 lp = vec3(0., 0., -1.0); // light pos
    if(mouse.z > 0.){
        lp.xy = m.xy;
    }
    vec3 sp = vec3(uv, 0.0); // surface pos
    vec3 ro = vec3(0, 0, -1.0); // origin pos
    vec3 rd = normalize(sp - ro); // origin to screen plane pos
   
    vec3 ld = lp - sp;
    
    float dist = max(length(ld), 0.001);
    ld /= dist;
    vec3 objCol = color(uv);
    
    
    vec3 norm = BumpedNormal(uv, 48.0);
    norm.xy*=-1.0;
    
    vec3 ref = reflect(-rd, norm);
   
    
    float dif = max(dot(norm, ld), 0.);  
    float spec = pow(max(dot( reflect(-ld, norm), -rd), 0.), 14.);
    float falloff = 1.5/(0.8 + dist*2.4);
    
    
    vec3 col = (objCol*(dif + .25) + vec3(0.5, 0.5, 0.5)*spec*2.25)*falloff;
	//col = mix(col, refcol, zval*0.15);
    
    gl_FragColor = vec4(col, 1.0);
    
}




